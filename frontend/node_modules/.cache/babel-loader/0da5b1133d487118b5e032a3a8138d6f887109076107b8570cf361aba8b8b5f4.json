{"ast":null,"code":"/*!\n* chartjs-plugin-zoom v2.2.0\n* https://www.chartjs.org/chartjs-plugin-zoom/2.2.0/\n * (c) 2016-2024 chartjs-plugin-zoom Contributors\n * Released under the MIT License\n */\nimport Hammer from 'hammerjs';\nimport { each, valueOrDefault, almostEquals, callback, sign, getRelativePosition, _isPointInArea } from 'chart.js/helpers';\nconst getModifierKey = opts => opts && opts.enabled && opts.modifierKey;\nconst keyPressed = (key, event) => key && event[key + 'Key'];\nconst keyNotPressed = (key, event) => key && !event[key + 'Key'];\nfunction directionEnabled(mode, dir, chart) {\n  if (mode === undefined) {\n    return true;\n  } else if (typeof mode === 'string') {\n    return mode.indexOf(dir) !== -1;\n  } else if (typeof mode === 'function') {\n    return mode({\n      chart\n    }).indexOf(dir) !== -1;\n  }\n  return false;\n}\nfunction directionsEnabled(mode, chart) {\n  if (typeof mode === 'function') {\n    mode = mode({\n      chart\n    });\n  }\n  if (typeof mode === 'string') {\n    return {\n      x: mode.indexOf('x') !== -1,\n      y: mode.indexOf('y') !== -1\n    };\n  }\n  return {\n    x: false,\n    y: false\n  };\n}\nfunction debounce(fn, delay) {\n  let timeout;\n  return function () {\n    clearTimeout(timeout);\n    timeout = setTimeout(fn, delay);\n    return delay;\n  };\n}\nfunction getScaleUnderPoint({\n  x,\n  y\n}, chart) {\n  const scales = chart.scales;\n  const scaleIds = Object.keys(scales);\n  for (let i = 0; i < scaleIds.length; i++) {\n    const scale = scales[scaleIds[i]];\n    if (y >= scale.top && y <= scale.bottom && x >= scale.left && x <= scale.right) {\n      return scale;\n    }\n  }\n  return null;\n}\nfunction getEnabledScalesByPoint(options, point, chart) {\n  const {\n    mode = 'xy',\n    scaleMode,\n    overScaleMode\n  } = options || {};\n  const scale = getScaleUnderPoint(point, chart);\n  const enabled = directionsEnabled(mode, chart);\n  const scaleEnabled = directionsEnabled(scaleMode, chart);\n  if (overScaleMode) {\n    const overScaleEnabled = directionsEnabled(overScaleMode, chart);\n    for (const axis of ['x', 'y']) {\n      if (overScaleEnabled[axis]) {\n        scaleEnabled[axis] = enabled[axis];\n        enabled[axis] = false;\n      }\n    }\n  }\n  if (scale && scaleEnabled[scale.axis]) {\n    return [scale];\n  }\n  const enabledScales = [];\n  each(chart.scales, function (scaleItem) {\n    if (enabled[scaleItem.axis]) {\n      enabledScales.push(scaleItem);\n    }\n  });\n  return enabledScales;\n}\nconst chartStates = new WeakMap();\nfunction getState(chart) {\n  let state = chartStates.get(chart);\n  if (!state) {\n    state = {\n      originalScaleLimits: {},\n      updatedScaleLimits: {},\n      handlers: {},\n      panDelta: {},\n      dragging: false,\n      panning: false\n    };\n    chartStates.set(chart, state);\n  }\n  return state;\n}\nfunction removeState(chart) {\n  chartStates.delete(chart);\n}\nfunction zoomDelta(val, min, range, newRange) {\n  const minPercent = Math.max(0, Math.min(1, (val - min) / range || 0));\n  const maxPercent = 1 - minPercent;\n  return {\n    min: newRange * minPercent,\n    max: newRange * maxPercent\n  };\n}\nfunction getValueAtPoint(scale, point) {\n  const pixel = scale.isHorizontal() ? point.x : point.y;\n  return scale.getValueForPixel(pixel);\n}\nfunction linearZoomDelta(scale, zoom, center) {\n  const range = scale.max - scale.min;\n  const newRange = range * (zoom - 1);\n  const centerValue = getValueAtPoint(scale, center);\n  return zoomDelta(centerValue, scale.min, range, newRange);\n}\nfunction logarithmicZoomRange(scale, zoom, center) {\n  const centerValue = getValueAtPoint(scale, center);\n  if (centerValue === undefined) {\n    return {\n      min: scale.min,\n      max: scale.max\n    };\n  }\n  const logMin = Math.log10(scale.min);\n  const logMax = Math.log10(scale.max);\n  const logCenter = Math.log10(centerValue);\n  const logRange = logMax - logMin;\n  const newLogRange = logRange * (zoom - 1);\n  const delta = zoomDelta(logCenter, logMin, logRange, newLogRange);\n  return {\n    min: Math.pow(10, logMin + delta.min),\n    max: Math.pow(10, logMax - delta.max)\n  };\n}\nfunction getScaleLimits(scale, limits) {\n  return limits && (limits[scale.id] || limits[scale.axis]) || {};\n}\nfunction getLimit(state, scale, scaleLimits, prop, fallback) {\n  let limit = scaleLimits[prop];\n  if (limit === 'original') {\n    const original = state.originalScaleLimits[scale.id][prop];\n    limit = valueOrDefault(original.options, original.scale);\n  }\n  return valueOrDefault(limit, fallback);\n}\nfunction linearRange(scale, pixel0, pixel1) {\n  const v0 = scale.getValueForPixel(pixel0);\n  const v1 = scale.getValueForPixel(pixel1);\n  return {\n    min: Math.min(v0, v1),\n    max: Math.max(v0, v1)\n  };\n}\nfunction fixRange(range, {\n  min,\n  max,\n  minLimit,\n  maxLimit\n}, originalLimits) {\n  const offset = (range - max + min) / 2;\n  min -= offset;\n  max += offset;\n  const origMin = originalLimits.min.options ?? originalLimits.min.scale;\n  const origMax = originalLimits.max.options ?? originalLimits.max.scale;\n  const epsilon = range / 1e6;\n  if (almostEquals(min, origMin, epsilon)) {\n    min = origMin;\n  }\n  if (almostEquals(max, origMax, epsilon)) {\n    max = origMax;\n  }\n  if (min < minLimit) {\n    min = minLimit;\n    max = Math.min(minLimit + range, maxLimit);\n  } else if (max > maxLimit) {\n    max = maxLimit;\n    min = Math.max(maxLimit - range, minLimit);\n  }\n  return {\n    min,\n    max\n  };\n}\nfunction updateRange(scale, {\n  min,\n  max\n}, limits, zoom = false) {\n  const state = getState(scale.chart);\n  const {\n    options: scaleOpts\n  } = scale;\n  const scaleLimits = getScaleLimits(scale, limits);\n  const {\n    minRange = 0\n  } = scaleLimits;\n  const minLimit = getLimit(state, scale, scaleLimits, 'min', -Infinity);\n  const maxLimit = getLimit(state, scale, scaleLimits, 'max', Infinity);\n  if (zoom === 'pan' && (min < minLimit || max > maxLimit)) {\n    return true;\n  }\n  const scaleRange = scale.max - scale.min;\n  const range = zoom ? Math.max(max - min, minRange) : scaleRange;\n  if (zoom && range === minRange && scaleRange <= minRange) {\n    return true;\n  }\n  const newRange = fixRange(range, {\n    min,\n    max,\n    minLimit,\n    maxLimit\n  }, state.originalScaleLimits[scale.id]);\n  scaleOpts.min = newRange.min;\n  scaleOpts.max = newRange.max;\n  state.updatedScaleLimits[scale.id] = newRange;\n  return scale.parse(newRange.min) !== scale.min || scale.parse(newRange.max) !== scale.max;\n}\nfunction zoomNumericalScale(scale, zoom, center, limits) {\n  const delta = linearZoomDelta(scale, zoom, center);\n  const newRange = {\n    min: scale.min + delta.min,\n    max: scale.max - delta.max\n  };\n  return updateRange(scale, newRange, limits, true);\n}\nfunction zoomLogarithmicScale(scale, zoom, center, limits) {\n  const newRange = logarithmicZoomRange(scale, zoom, center);\n  return updateRange(scale, newRange, limits, true);\n}\nfunction zoomRectNumericalScale(scale, from, to, limits) {\n  updateRange(scale, linearRange(scale, from, to), limits, true);\n}\nconst integerChange = v => v === 0 || isNaN(v) ? 0 : v < 0 ? Math.min(Math.round(v), -1) : Math.max(Math.round(v), 1);\nfunction existCategoryFromMaxZoom(scale) {\n  const labels = scale.getLabels();\n  const maxIndex = labels.length - 1;\n  if (scale.min > 0) {\n    scale.min -= 1;\n  }\n  if (scale.max < maxIndex) {\n    scale.max += 1;\n  }\n}\nfunction zoomCategoryScale(scale, zoom, center, limits) {\n  const delta = linearZoomDelta(scale, zoom, center);\n  if (scale.min === scale.max && zoom < 1) {\n    existCategoryFromMaxZoom(scale);\n  }\n  const newRange = {\n    min: scale.min + integerChange(delta.min),\n    max: scale.max - integerChange(delta.max)\n  };\n  return updateRange(scale, newRange, limits, true);\n}\nfunction scaleLength(scale) {\n  return scale.isHorizontal() ? scale.width : scale.height;\n}\nfunction panCategoryScale(scale, delta, limits) {\n  const labels = scale.getLabels();\n  const lastLabelIndex = labels.length - 1;\n  let {\n    min,\n    max\n  } = scale;\n  const range = Math.max(max - min, 1);\n  const stepDelta = Math.round(scaleLength(scale) / Math.max(range, 10));\n  const stepSize = Math.round(Math.abs(delta / stepDelta));\n  let applied;\n  if (delta < -stepDelta) {\n    max = Math.min(max + stepSize, lastLabelIndex);\n    min = range === 1 ? max : max - range;\n    applied = max === lastLabelIndex;\n  } else if (delta > stepDelta) {\n    min = Math.max(0, min - stepSize);\n    max = range === 1 ? min : min + range;\n    applied = min === 0;\n  }\n  return updateRange(scale, {\n    min,\n    max\n  }, limits) || applied;\n}\nconst OFFSETS = {\n  second: 500,\n  minute: 30 * 1000,\n  hour: 30 * 60 * 1000,\n  day: 12 * 60 * 60 * 1000,\n  week: 3.5 * 24 * 60 * 60 * 1000,\n  month: 15 * 24 * 60 * 60 * 1000,\n  quarter: 60 * 24 * 60 * 60 * 1000,\n  year: 182 * 24 * 60 * 60 * 1000\n};\nfunction panNumericalScale(scale, delta, limits, pan = false) {\n  const {\n    min: prevStart,\n    max: prevEnd,\n    options\n  } = scale;\n  const round = options.time && options.time.round;\n  const offset = OFFSETS[round] || 0;\n  const newMin = scale.getValueForPixel(scale.getPixelForValue(prevStart + offset) - delta);\n  const newMax = scale.getValueForPixel(scale.getPixelForValue(prevEnd + offset) - delta);\n  if (isNaN(newMin) || isNaN(newMax)) {\n    return true;\n  }\n  return updateRange(scale, {\n    min: newMin,\n    max: newMax\n  }, limits, pan ? 'pan' : false);\n}\nfunction panNonLinearScale(scale, delta, limits) {\n  return panNumericalScale(scale, delta, limits, true);\n}\nconst zoomFunctions = {\n  category: zoomCategoryScale,\n  default: zoomNumericalScale,\n  logarithmic: zoomLogarithmicScale\n};\nconst zoomRectFunctions = {\n  default: zoomRectNumericalScale\n};\nconst panFunctions = {\n  category: panCategoryScale,\n  default: panNumericalScale,\n  logarithmic: panNonLinearScale,\n  timeseries: panNonLinearScale\n};\nfunction shouldUpdateScaleLimits(scale, originalScaleLimits, updatedScaleLimits) {\n  const {\n    id,\n    options: {\n      min,\n      max\n    }\n  } = scale;\n  if (!originalScaleLimits[id] || !updatedScaleLimits[id]) {\n    return true;\n  }\n  const previous = updatedScaleLimits[id];\n  return previous.min !== min || previous.max !== max;\n}\nfunction removeMissingScales(limits, scales) {\n  each(limits, (opt, key) => {\n    if (!scales[key]) {\n      delete limits[key];\n    }\n  });\n}\nfunction storeOriginalScaleLimits(chart, state) {\n  const {\n    scales\n  } = chart;\n  const {\n    originalScaleLimits,\n    updatedScaleLimits\n  } = state;\n  each(scales, function (scale) {\n    if (shouldUpdateScaleLimits(scale, originalScaleLimits, updatedScaleLimits)) {\n      originalScaleLimits[scale.id] = {\n        min: {\n          scale: scale.min,\n          options: scale.options.min\n        },\n        max: {\n          scale: scale.max,\n          options: scale.options.max\n        }\n      };\n    }\n  });\n  removeMissingScales(originalScaleLimits, scales);\n  removeMissingScales(updatedScaleLimits, scales);\n  return originalScaleLimits;\n}\nfunction doZoom(scale, amount, center, limits) {\n  const fn = zoomFunctions[scale.type] || zoomFunctions.default;\n  callback(fn, [scale, amount, center, limits]);\n}\nfunction doZoomRect(scale, from, to, limits) {\n  const fn = zoomRectFunctions[scale.type] || zoomRectFunctions.default;\n  callback(fn, [scale, from, to, limits]);\n}\nfunction getCenter(chart) {\n  const ca = chart.chartArea;\n  return {\n    x: (ca.left + ca.right) / 2,\n    y: (ca.top + ca.bottom) / 2\n  };\n}\nfunction zoom(chart, amount, transition = 'none', trigger = 'api') {\n  const {\n    x = 1,\n    y = 1,\n    focalPoint = getCenter(chart)\n  } = typeof amount === 'number' ? {\n    x: amount,\n    y: amount\n  } : amount;\n  const state = getState(chart);\n  const {\n    options: {\n      limits,\n      zoom: zoomOptions\n    }\n  } = state;\n  storeOriginalScaleLimits(chart, state);\n  const xEnabled = x !== 1;\n  const yEnabled = y !== 1;\n  const enabledScales = getEnabledScalesByPoint(zoomOptions, focalPoint, chart);\n  each(enabledScales || chart.scales, function (scale) {\n    if (scale.isHorizontal() && xEnabled) {\n      doZoom(scale, x, focalPoint, limits);\n    } else if (!scale.isHorizontal() && yEnabled) {\n      doZoom(scale, y, focalPoint, limits);\n    }\n  });\n  chart.update(transition);\n  callback(zoomOptions.onZoom, [{\n    chart,\n    trigger\n  }]);\n}\nfunction zoomRect(chart, p0, p1, transition = 'none', trigger = 'api') {\n  const state = getState(chart);\n  const {\n    options: {\n      limits,\n      zoom: zoomOptions\n    }\n  } = state;\n  const {\n    mode = 'xy'\n  } = zoomOptions;\n  storeOriginalScaleLimits(chart, state);\n  const xEnabled = directionEnabled(mode, 'x', chart);\n  const yEnabled = directionEnabled(mode, 'y', chart);\n  each(chart.scales, function (scale) {\n    if (scale.isHorizontal() && xEnabled) {\n      doZoomRect(scale, p0.x, p1.x, limits);\n    } else if (!scale.isHorizontal() && yEnabled) {\n      doZoomRect(scale, p0.y, p1.y, limits);\n    }\n  });\n  chart.update(transition);\n  callback(zoomOptions.onZoom, [{\n    chart,\n    trigger\n  }]);\n}\nfunction zoomScale(chart, scaleId, range, transition = 'none', trigger = 'api') {\n  const state = getState(chart);\n  storeOriginalScaleLimits(chart, state);\n  const scale = chart.scales[scaleId];\n  updateRange(scale, range, undefined, true);\n  chart.update(transition);\n  callback(state.options.zoom?.onZoom, [{\n    chart,\n    trigger\n  }]);\n}\nfunction resetZoom(chart, transition = 'default') {\n  const state = getState(chart);\n  const originalScaleLimits = storeOriginalScaleLimits(chart, state);\n  each(chart.scales, function (scale) {\n    const scaleOptions = scale.options;\n    if (originalScaleLimits[scale.id]) {\n      scaleOptions.min = originalScaleLimits[scale.id].min.options;\n      scaleOptions.max = originalScaleLimits[scale.id].max.options;\n    } else {\n      delete scaleOptions.min;\n      delete scaleOptions.max;\n    }\n    delete state.updatedScaleLimits[scale.id];\n  });\n  chart.update(transition);\n  callback(state.options.zoom.onZoomComplete, [{\n    chart\n  }]);\n}\nfunction getOriginalRange(state, scaleId) {\n  const original = state.originalScaleLimits[scaleId];\n  if (!original) {\n    return;\n  }\n  const {\n    min,\n    max\n  } = original;\n  return valueOrDefault(max.options, max.scale) - valueOrDefault(min.options, min.scale);\n}\nfunction getZoomLevel(chart) {\n  const state = getState(chart);\n  let min = 1;\n  let max = 1;\n  each(chart.scales, function (scale) {\n    const origRange = getOriginalRange(state, scale.id);\n    if (origRange) {\n      const level = Math.round(origRange / (scale.max - scale.min) * 100) / 100;\n      min = Math.min(min, level);\n      max = Math.max(max, level);\n    }\n  });\n  return min < 1 ? min : max;\n}\nfunction panScale(scale, delta, limits, state) {\n  const {\n    panDelta\n  } = state;\n  const storedDelta = panDelta[scale.id] || 0;\n  if (sign(storedDelta) === sign(delta)) {\n    delta += storedDelta;\n  }\n  const fn = panFunctions[scale.type] || panFunctions.default;\n  if (callback(fn, [scale, delta, limits])) {\n    panDelta[scale.id] = 0;\n  } else {\n    panDelta[scale.id] = delta;\n  }\n}\nfunction pan(chart, delta, enabledScales, transition = 'none') {\n  const {\n    x = 0,\n    y = 0\n  } = typeof delta === 'number' ? {\n    x: delta,\n    y: delta\n  } : delta;\n  const state = getState(chart);\n  const {\n    options: {\n      pan: panOptions,\n      limits\n    }\n  } = state;\n  const {\n    onPan\n  } = panOptions || {};\n  storeOriginalScaleLimits(chart, state);\n  const xEnabled = x !== 0;\n  const yEnabled = y !== 0;\n  each(enabledScales || chart.scales, function (scale) {\n    if (scale.isHorizontal() && xEnabled) {\n      panScale(scale, x, limits, state);\n    } else if (!scale.isHorizontal() && yEnabled) {\n      panScale(scale, y, limits, state);\n    }\n  });\n  chart.update(transition);\n  callback(onPan, [{\n    chart\n  }]);\n}\nfunction getInitialScaleBounds(chart) {\n  const state = getState(chart);\n  storeOriginalScaleLimits(chart, state);\n  const scaleBounds = {};\n  for (const scaleId of Object.keys(chart.scales)) {\n    const {\n      min,\n      max\n    } = state.originalScaleLimits[scaleId] || {\n      min: {},\n      max: {}\n    };\n    scaleBounds[scaleId] = {\n      min: min.scale,\n      max: max.scale\n    };\n  }\n  return scaleBounds;\n}\nfunction getZoomedScaleBounds(chart) {\n  const state = getState(chart);\n  const scaleBounds = {};\n  for (const scaleId of Object.keys(chart.scales)) {\n    scaleBounds[scaleId] = state.updatedScaleLimits[scaleId];\n  }\n  return scaleBounds;\n}\nfunction isZoomedOrPanned(chart) {\n  const scaleBounds = getInitialScaleBounds(chart);\n  for (const scaleId of Object.keys(chart.scales)) {\n    const {\n      min: originalMin,\n      max: originalMax\n    } = scaleBounds[scaleId];\n    if (originalMin !== undefined && chart.scales[scaleId].min !== originalMin) {\n      return true;\n    }\n    if (originalMax !== undefined && chart.scales[scaleId].max !== originalMax) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction isZoomingOrPanning(chart) {\n  const state = getState(chart);\n  return state.panning || state.dragging;\n}\nconst clamp = (x, from, to) => Math.min(to, Math.max(from, x));\nfunction removeHandler(chart, type) {\n  const {\n    handlers\n  } = getState(chart);\n  const handler = handlers[type];\n  if (handler && handler.target) {\n    handler.target.removeEventListener(type, handler);\n    delete handlers[type];\n  }\n}\nfunction addHandler(chart, target, type, handler) {\n  const {\n    handlers,\n    options\n  } = getState(chart);\n  const oldHandler = handlers[type];\n  if (oldHandler && oldHandler.target === target) {\n    return;\n  }\n  removeHandler(chart, type);\n  handlers[type] = event => handler(chart, event, options);\n  handlers[type].target = target;\n  const passive = type === 'wheel' ? false : undefined;\n  target.addEventListener(type, handlers[type], {\n    passive\n  });\n}\nfunction mouseMove(chart, event) {\n  const state = getState(chart);\n  if (state.dragStart) {\n    state.dragging = true;\n    state.dragEnd = event;\n    chart.update('none');\n  }\n}\nfunction keyDown(chart, event) {\n  const state = getState(chart);\n  if (!state.dragStart || event.key !== 'Escape') {\n    return;\n  }\n  removeHandler(chart, 'keydown');\n  state.dragging = false;\n  state.dragStart = state.dragEnd = null;\n  chart.update('none');\n}\nfunction getPointPosition(event, chart) {\n  if (event.target !== chart.canvas) {\n    const canvasArea = chart.canvas.getBoundingClientRect();\n    return {\n      x: event.clientX - canvasArea.left,\n      y: event.clientY - canvasArea.top\n    };\n  }\n  return getRelativePosition(event, chart);\n}\nfunction zoomStart(chart, event, zoomOptions) {\n  const {\n    onZoomStart,\n    onZoomRejected\n  } = zoomOptions;\n  if (onZoomStart) {\n    const point = getPointPosition(event, chart);\n    if (callback(onZoomStart, [{\n      chart,\n      event,\n      point\n    }]) === false) {\n      callback(onZoomRejected, [{\n        chart,\n        event\n      }]);\n      return false;\n    }\n  }\n}\nfunction mouseDown(chart, event) {\n  if (chart.legend) {\n    const point = getRelativePosition(event, chart);\n    if (_isPointInArea(point, chart.legend)) {\n      return;\n    }\n  }\n  const state = getState(chart);\n  const {\n    pan: panOptions,\n    zoom: zoomOptions = {}\n  } = state.options;\n  if (event.button !== 0 || keyPressed(getModifierKey(panOptions), event) || keyNotPressed(getModifierKey(zoomOptions.drag), event)) {\n    return callback(zoomOptions.onZoomRejected, [{\n      chart,\n      event\n    }]);\n  }\n  if (zoomStart(chart, event, zoomOptions) === false) {\n    return;\n  }\n  state.dragStart = event;\n  addHandler(chart, chart.canvas.ownerDocument, 'mousemove', mouseMove);\n  addHandler(chart, window.document, 'keydown', keyDown);\n}\nfunction applyAspectRatio({\n  begin,\n  end\n}, aspectRatio) {\n  let width = end.x - begin.x;\n  let height = end.y - begin.y;\n  const ratio = Math.abs(width / height);\n  if (ratio > aspectRatio) {\n    width = Math.sign(width) * Math.abs(height * aspectRatio);\n  } else if (ratio < aspectRatio) {\n    height = Math.sign(height) * Math.abs(width / aspectRatio);\n  }\n  end.x = begin.x + width;\n  end.y = begin.y + height;\n}\nfunction applyMinMaxProps(rect, chartArea, points, {\n  min,\n  max,\n  prop\n}) {\n  rect[min] = clamp(Math.min(points.begin[prop], points.end[prop]), chartArea[min], chartArea[max]);\n  rect[max] = clamp(Math.max(points.begin[prop], points.end[prop]), chartArea[min], chartArea[max]);\n}\nfunction getRelativePoints(chart, pointEvents, maintainAspectRatio) {\n  const points = {\n    begin: getPointPosition(pointEvents.dragStart, chart),\n    end: getPointPosition(pointEvents.dragEnd, chart)\n  };\n  if (maintainAspectRatio) {\n    const aspectRatio = chart.chartArea.width / chart.chartArea.height;\n    applyAspectRatio(points, aspectRatio);\n  }\n  return points;\n}\nfunction computeDragRect(chart, mode, pointEvents, maintainAspectRatio) {\n  const xEnabled = directionEnabled(mode, 'x', chart);\n  const yEnabled = directionEnabled(mode, 'y', chart);\n  const {\n    top,\n    left,\n    right,\n    bottom,\n    width: chartWidth,\n    height: chartHeight\n  } = chart.chartArea;\n  const rect = {\n    top,\n    left,\n    right,\n    bottom\n  };\n  const points = getRelativePoints(chart, pointEvents, maintainAspectRatio && xEnabled && yEnabled);\n  if (xEnabled) {\n    applyMinMaxProps(rect, chart.chartArea, points, {\n      min: 'left',\n      max: 'right',\n      prop: 'x'\n    });\n  }\n  if (yEnabled) {\n    applyMinMaxProps(rect, chart.chartArea, points, {\n      min: 'top',\n      max: 'bottom',\n      prop: 'y'\n    });\n  }\n  const width = rect.right - rect.left;\n  const height = rect.bottom - rect.top;\n  return {\n    ...rect,\n    width,\n    height,\n    zoomX: xEnabled && width ? 1 + (chartWidth - width) / chartWidth : 1,\n    zoomY: yEnabled && height ? 1 + (chartHeight - height) / chartHeight : 1\n  };\n}\nfunction mouseUp(chart, event) {\n  const state = getState(chart);\n  if (!state.dragStart) {\n    return;\n  }\n  removeHandler(chart, 'mousemove');\n  const {\n    mode,\n    onZoomComplete,\n    drag: {\n      threshold = 0,\n      maintainAspectRatio\n    }\n  } = state.options.zoom;\n  const rect = computeDragRect(chart, mode, {\n    dragStart: state.dragStart,\n    dragEnd: event\n  }, maintainAspectRatio);\n  const distanceX = directionEnabled(mode, 'x', chart) ? rect.width : 0;\n  const distanceY = directionEnabled(mode, 'y', chart) ? rect.height : 0;\n  const distance = Math.sqrt(distanceX * distanceX + distanceY * distanceY);\n  state.dragStart = state.dragEnd = null;\n  if (distance <= threshold) {\n    state.dragging = false;\n    chart.update('none');\n    return;\n  }\n  zoomRect(chart, {\n    x: rect.left,\n    y: rect.top\n  }, {\n    x: rect.right,\n    y: rect.bottom\n  }, 'zoom', 'drag');\n  state.dragging = false;\n  state.filterNextClick = true;\n  callback(onZoomComplete, [{\n    chart\n  }]);\n}\nfunction wheelPreconditions(chart, event, zoomOptions) {\n  if (keyNotPressed(getModifierKey(zoomOptions.wheel), event)) {\n    callback(zoomOptions.onZoomRejected, [{\n      chart,\n      event\n    }]);\n    return;\n  }\n  if (zoomStart(chart, event, zoomOptions) === false) {\n    return;\n  }\n  if (event.cancelable) {\n    event.preventDefault();\n  }\n  if (event.deltaY === undefined) {\n    return;\n  }\n  return true;\n}\nfunction wheel(chart, event) {\n  const {\n    handlers: {\n      onZoomComplete\n    },\n    options: {\n      zoom: zoomOptions\n    }\n  } = getState(chart);\n  if (!wheelPreconditions(chart, event, zoomOptions)) {\n    return;\n  }\n  const rect = event.target.getBoundingClientRect();\n  const speed = zoomOptions.wheel.speed;\n  const percentage = event.deltaY >= 0 ? 2 - 1 / (1 - speed) : 1 + speed;\n  const amount = {\n    x: percentage,\n    y: percentage,\n    focalPoint: {\n      x: event.clientX - rect.left,\n      y: event.clientY - rect.top\n    }\n  };\n  zoom(chart, amount, 'zoom', 'wheel');\n  callback(onZoomComplete, [{\n    chart\n  }]);\n}\nfunction addDebouncedHandler(chart, name, handler, delay) {\n  if (handler) {\n    getState(chart).handlers[name] = debounce(() => callback(handler, [{\n      chart\n    }]), delay);\n  }\n}\nfunction addListeners(chart, options) {\n  const canvas = chart.canvas;\n  const {\n    wheel: wheelOptions,\n    drag: dragOptions,\n    onZoomComplete\n  } = options.zoom;\n  if (wheelOptions.enabled) {\n    addHandler(chart, canvas, 'wheel', wheel);\n    addDebouncedHandler(chart, 'onZoomComplete', onZoomComplete, 250);\n  } else {\n    removeHandler(chart, 'wheel');\n  }\n  if (dragOptions.enabled) {\n    addHandler(chart, canvas, 'mousedown', mouseDown);\n    addHandler(chart, canvas.ownerDocument, 'mouseup', mouseUp);\n  } else {\n    removeHandler(chart, 'mousedown');\n    removeHandler(chart, 'mousemove');\n    removeHandler(chart, 'mouseup');\n    removeHandler(chart, 'keydown');\n  }\n}\nfunction removeListeners(chart) {\n  removeHandler(chart, 'mousedown');\n  removeHandler(chart, 'mousemove');\n  removeHandler(chart, 'mouseup');\n  removeHandler(chart, 'wheel');\n  removeHandler(chart, 'click');\n  removeHandler(chart, 'keydown');\n}\nfunction createEnabler(chart, state) {\n  return function (recognizer, event) {\n    const {\n      pan: panOptions,\n      zoom: zoomOptions = {}\n    } = state.options;\n    if (!panOptions || !panOptions.enabled) {\n      return false;\n    }\n    const srcEvent = event && event.srcEvent;\n    if (!srcEvent) {\n      return true;\n    }\n    if (!state.panning && event.pointerType === 'mouse' && (keyNotPressed(getModifierKey(panOptions), srcEvent) || keyPressed(getModifierKey(zoomOptions.drag), srcEvent))) {\n      callback(panOptions.onPanRejected, [{\n        chart,\n        event\n      }]);\n      return false;\n    }\n    return true;\n  };\n}\nfunction pinchAxes(p0, p1) {\n  const pinchX = Math.abs(p0.clientX - p1.clientX);\n  const pinchY = Math.abs(p0.clientY - p1.clientY);\n  const p = pinchX / pinchY;\n  let x, y;\n  if (p > 0.3 && p < 1.7) {\n    x = y = true;\n  } else if (pinchX > pinchY) {\n    x = true;\n  } else {\n    y = true;\n  }\n  return {\n    x,\n    y\n  };\n}\nfunction handlePinch(chart, state, e) {\n  if (state.scale) {\n    const {\n      center,\n      pointers\n    } = e;\n    const zoomPercent = 1 / state.scale * e.scale;\n    const rect = e.target.getBoundingClientRect();\n    const pinch = pinchAxes(pointers[0], pointers[1]);\n    const mode = state.options.zoom.mode;\n    const amount = {\n      x: pinch.x && directionEnabled(mode, 'x', chart) ? zoomPercent : 1,\n      y: pinch.y && directionEnabled(mode, 'y', chart) ? zoomPercent : 1,\n      focalPoint: {\n        x: center.x - rect.left,\n        y: center.y - rect.top\n      }\n    };\n    zoom(chart, amount, 'zoom', 'pinch');\n    state.scale = e.scale;\n  }\n}\nfunction startPinch(chart, state, event) {\n  if (state.options.zoom.pinch.enabled) {\n    const point = getRelativePosition(event, chart);\n    if (callback(state.options.zoom.onZoomStart, [{\n      chart,\n      event,\n      point\n    }]) === false) {\n      state.scale = null;\n      callback(state.options.zoom.onZoomRejected, [{\n        chart,\n        event\n      }]);\n    } else {\n      state.scale = 1;\n    }\n  }\n}\nfunction endPinch(chart, state, e) {\n  if (state.scale) {\n    handlePinch(chart, state, e);\n    state.scale = null;\n    callback(state.options.zoom.onZoomComplete, [{\n      chart\n    }]);\n  }\n}\nfunction handlePan(chart, state, e) {\n  const delta = state.delta;\n  if (delta) {\n    state.panning = true;\n    pan(chart, {\n      x: e.deltaX - delta.x,\n      y: e.deltaY - delta.y\n    }, state.panScales);\n    state.delta = {\n      x: e.deltaX,\n      y: e.deltaY\n    };\n  }\n}\nfunction startPan(chart, state, event) {\n  const {\n    enabled,\n    onPanStart,\n    onPanRejected\n  } = state.options.pan;\n  if (!enabled) {\n    return;\n  }\n  const rect = event.target.getBoundingClientRect();\n  const point = {\n    x: event.center.x - rect.left,\n    y: event.center.y - rect.top\n  };\n  if (callback(onPanStart, [{\n    chart,\n    event,\n    point\n  }]) === false) {\n    return callback(onPanRejected, [{\n      chart,\n      event\n    }]);\n  }\n  state.panScales = getEnabledScalesByPoint(state.options.pan, point, chart);\n  state.delta = {\n    x: 0,\n    y: 0\n  };\n  handlePan(chart, state, event);\n}\nfunction endPan(chart, state) {\n  state.delta = null;\n  if (state.panning) {\n    state.panning = false;\n    state.filterNextClick = true;\n    callback(state.options.pan.onPanComplete, [{\n      chart\n    }]);\n  }\n}\nconst hammers = new WeakMap();\nfunction startHammer(chart, options) {\n  const state = getState(chart);\n  const canvas = chart.canvas;\n  const {\n    pan: panOptions,\n    zoom: zoomOptions\n  } = options;\n  const mc = new Hammer.Manager(canvas);\n  if (zoomOptions && zoomOptions.pinch.enabled) {\n    mc.add(new Hammer.Pinch());\n    mc.on('pinchstart', e => startPinch(chart, state, e));\n    mc.on('pinch', e => handlePinch(chart, state, e));\n    mc.on('pinchend', e => endPinch(chart, state, e));\n  }\n  if (panOptions && panOptions.enabled) {\n    mc.add(new Hammer.Pan({\n      threshold: panOptions.threshold,\n      enable: createEnabler(chart, state)\n    }));\n    mc.on('panstart', e => startPan(chart, state, e));\n    mc.on('panmove', e => handlePan(chart, state, e));\n    mc.on('panend', () => endPan(chart, state));\n  }\n  hammers.set(chart, mc);\n}\nfunction stopHammer(chart) {\n  const mc = hammers.get(chart);\n  if (mc) {\n    mc.remove('pinchstart');\n    mc.remove('pinch');\n    mc.remove('pinchend');\n    mc.remove('panstart');\n    mc.remove('pan');\n    mc.remove('panend');\n    mc.destroy();\n    hammers.delete(chart);\n  }\n}\nfunction hammerOptionsChanged(oldOptions, newOptions) {\n  const {\n    pan: oldPan,\n    zoom: oldZoom\n  } = oldOptions;\n  const {\n    pan: newPan,\n    zoom: newZoom\n  } = newOptions;\n  if (oldZoom?.zoom?.pinch?.enabled !== newZoom?.zoom?.pinch?.enabled) {\n    return true;\n  }\n  if (oldPan?.enabled !== newPan?.enabled) {\n    return true;\n  }\n  if (oldPan?.threshold !== newPan?.threshold) {\n    return true;\n  }\n  return false;\n}\nvar version = \"2.2.0\";\nfunction draw(chart, caller, options) {\n  const dragOptions = options.zoom.drag;\n  const {\n    dragStart,\n    dragEnd\n  } = getState(chart);\n  if (dragOptions.drawTime !== caller || !dragEnd) {\n    return;\n  }\n  const {\n    left,\n    top,\n    width,\n    height\n  } = computeDragRect(chart, options.zoom.mode, {\n    dragStart,\n    dragEnd\n  }, dragOptions.maintainAspectRatio);\n  const ctx = chart.ctx;\n  ctx.save();\n  ctx.beginPath();\n  ctx.fillStyle = dragOptions.backgroundColor || 'rgba(225,225,225,0.3)';\n  ctx.fillRect(left, top, width, height);\n  if (dragOptions.borderWidth > 0) {\n    ctx.lineWidth = dragOptions.borderWidth;\n    ctx.strokeStyle = dragOptions.borderColor || 'rgba(225,225,225)';\n    ctx.strokeRect(left, top, width, height);\n  }\n  ctx.restore();\n}\nvar plugin = {\n  id: 'zoom',\n  version,\n  defaults: {\n    pan: {\n      enabled: false,\n      mode: 'xy',\n      threshold: 10,\n      modifierKey: null\n    },\n    zoom: {\n      wheel: {\n        enabled: false,\n        speed: 0.1,\n        modifierKey: null\n      },\n      drag: {\n        enabled: false,\n        drawTime: 'beforeDatasetsDraw',\n        modifierKey: null\n      },\n      pinch: {\n        enabled: false\n      },\n      mode: 'xy'\n    }\n  },\n  start: function (chart, _args, options) {\n    const state = getState(chart);\n    state.options = options;\n    if (Object.prototype.hasOwnProperty.call(options.zoom, 'enabled')) {\n      console.warn('The option `zoom.enabled` is no longer supported. Please use `zoom.wheel.enabled`, `zoom.drag.enabled`, or `zoom.pinch.enabled`.');\n    }\n    if (Object.prototype.hasOwnProperty.call(options.zoom, 'overScaleMode') || Object.prototype.hasOwnProperty.call(options.pan, 'overScaleMode')) {\n      console.warn('The option `overScaleMode` is deprecated. Please use `scaleMode` instead (and update `mode` as desired).');\n    }\n    if (Hammer) {\n      startHammer(chart, options);\n    }\n    chart.pan = (delta, panScales, transition) => pan(chart, delta, panScales, transition);\n    chart.zoom = (args, transition) => zoom(chart, args, transition);\n    chart.zoomRect = (p0, p1, transition) => zoomRect(chart, p0, p1, transition);\n    chart.zoomScale = (id, range, transition) => zoomScale(chart, id, range, transition);\n    chart.resetZoom = transition => resetZoom(chart, transition);\n    chart.getZoomLevel = () => getZoomLevel(chart);\n    chart.getInitialScaleBounds = () => getInitialScaleBounds(chart);\n    chart.getZoomedScaleBounds = () => getZoomedScaleBounds(chart);\n    chart.isZoomedOrPanned = () => isZoomedOrPanned(chart);\n    chart.isZoomingOrPanning = () => isZoomingOrPanning(chart);\n  },\n  beforeEvent(chart, {\n    event\n  }) {\n    if (isZoomingOrPanning(chart)) {\n      return false;\n    }\n    if (event.type === 'click' || event.type === 'mouseup') {\n      const state = getState(chart);\n      if (state.filterNextClick) {\n        state.filterNextClick = false;\n        return false;\n      }\n    }\n  },\n  beforeUpdate: function (chart, args, options) {\n    const state = getState(chart);\n    const previousOptions = state.options;\n    state.options = options;\n    if (hammerOptionsChanged(previousOptions, options)) {\n      stopHammer(chart);\n      startHammer(chart, options);\n    }\n    addListeners(chart, options);\n  },\n  beforeDatasetsDraw(chart, _args, options) {\n    draw(chart, 'beforeDatasetsDraw', options);\n  },\n  afterDatasetsDraw(chart, _args, options) {\n    draw(chart, 'afterDatasetsDraw', options);\n  },\n  beforeDraw(chart, _args, options) {\n    draw(chart, 'beforeDraw', options);\n  },\n  afterDraw(chart, _args, options) {\n    draw(chart, 'afterDraw', options);\n  },\n  stop: function (chart) {\n    removeListeners(chart);\n    if (Hammer) {\n      stopHammer(chart);\n    }\n    removeState(chart);\n  },\n  panFunctions,\n  zoomFunctions,\n  zoomRectFunctions\n};\nexport { plugin as default, pan, resetZoom, zoom, zoomRect, zoomScale };","map":{"version":3,"names":["Hammer","each","valueOrDefault","almostEquals","callback","sign","getRelativePosition","_isPointInArea","getModifierKey","opts","enabled","modifierKey","keyPressed","key","event","keyNotPressed","directionEnabled","mode","dir","chart","undefined","indexOf","directionsEnabled","x","y","debounce","fn","delay","timeout","clearTimeout","setTimeout","getScaleUnderPoint","scales","scaleIds","Object","keys","i","length","scale","top","bottom","left","right","getEnabledScalesByPoint","options","point","scaleMode","overScaleMode","scaleEnabled","overScaleEnabled","axis","enabledScales","scaleItem","push","chartStates","WeakMap","getState","state","get","originalScaleLimits","updatedScaleLimits","handlers","panDelta","dragging","panning","set","removeState","delete","zoomDelta","val","min","range","newRange","minPercent","Math","max","maxPercent","getValueAtPoint","pixel","isHorizontal","getValueForPixel","linearZoomDelta","zoom","center","centerValue","logarithmicZoomRange","logMin","log10","logMax","logCenter","logRange","newLogRange","delta","pow","getScaleLimits","limits","id","getLimit","scaleLimits","prop","fallback","limit","original","linearRange","pixel0","pixel1","v0","v1","fixRange","minLimit","maxLimit","originalLimits","offset","origMin","origMax","epsilon","updateRange","scaleOpts","minRange","Infinity","scaleRange","parse","zoomNumericalScale","zoomLogarithmicScale","zoomRectNumericalScale","from","to","integerChange","v","isNaN","round","existCategoryFromMaxZoom","labels","getLabels","maxIndex","zoomCategoryScale","scaleLength","width","height","panCategoryScale","lastLabelIndex","stepDelta","stepSize","abs","applied","OFFSETS","second","minute","hour","day","week","month","quarter","year","panNumericalScale","pan","prevStart","prevEnd","time","newMin","getPixelForValue","newMax","panNonLinearScale","zoomFunctions","category","default","logarithmic","zoomRectFunctions","panFunctions","timeseries","shouldUpdateScaleLimits","previous","removeMissingScales","opt","storeOriginalScaleLimits","doZoom","amount","type","doZoomRect","getCenter","ca","chartArea","transition","trigger","focalPoint","zoomOptions","xEnabled","yEnabled","update","onZoom","zoomRect","p0","p1","zoomScale","scaleId","resetZoom","scaleOptions","onZoomComplete","getOriginalRange","getZoomLevel","origRange","level","panScale","storedDelta","panOptions","onPan","getInitialScaleBounds","scaleBounds","getZoomedScaleBounds","isZoomedOrPanned","originalMin","originalMax","isZoomingOrPanning","clamp","removeHandler","handler","target","removeEventListener","addHandler","oldHandler","passive","addEventListener","mouseMove","dragStart","dragEnd","keyDown","getPointPosition","canvas","canvasArea","getBoundingClientRect","clientX","clientY","zoomStart","onZoomStart","onZoomRejected","mouseDown","legend","button","drag","ownerDocument","window","document","applyAspectRatio","begin","end","aspectRatio","ratio","applyMinMaxProps","rect","points","getRelativePoints","pointEvents","maintainAspectRatio","computeDragRect","chartWidth","chartHeight","zoomX","zoomY","mouseUp","threshold","distanceX","distanceY","distance","sqrt","filterNextClick","wheelPreconditions","wheel","cancelable","preventDefault","deltaY","speed","percentage","addDebouncedHandler","name","addListeners","wheelOptions","dragOptions","removeListeners","createEnabler","recognizer","srcEvent","pointerType","onPanRejected","pinchAxes","pinchX","pinchY","p","handlePinch","e","pointers","zoomPercent","pinch","startPinch","endPinch","handlePan","deltaX","panScales","startPan","onPanStart","endPan","onPanComplete","hammers","startHammer","mc","Manager","add","Pinch","on","Pan","enable","stopHammer","remove","destroy","hammerOptionsChanged","oldOptions","newOptions","oldPan","oldZoom","newPan","newZoom","version","draw","caller","drawTime","ctx","save","beginPath","fillStyle","backgroundColor","fillRect","borderWidth","lineWidth","strokeStyle","borderColor","strokeRect","restore","plugin","defaults","start","_args","prototype","hasOwnProperty","call","console","warn","args","beforeEvent","beforeUpdate","previousOptions","beforeDatasetsDraw","afterDatasetsDraw","beforeDraw","afterDraw","stop"],"sources":["/Users/chilaka/Documents/Projects/data_visualisation/frontend/node_modules/chartjs-plugin-zoom/dist/chartjs-plugin-zoom.esm.js"],"sourcesContent":["/*!\n* chartjs-plugin-zoom v2.2.0\n* https://www.chartjs.org/chartjs-plugin-zoom/2.2.0/\n * (c) 2016-2024 chartjs-plugin-zoom Contributors\n * Released under the MIT License\n */\nimport Hammer from 'hammerjs';\nimport { each, valueOrDefault, almostEquals, callback, sign, getRelativePosition, _isPointInArea } from 'chart.js/helpers';\n\nconst getModifierKey = opts => opts && opts.enabled && opts.modifierKey;\nconst keyPressed = (key, event) => key && event[key + 'Key'];\nconst keyNotPressed = (key, event) => key && !event[key + 'Key'];\nfunction directionEnabled(mode, dir, chart) {\n  if (mode === undefined) {\n    return true;\n  } else if (typeof mode === 'string') {\n    return mode.indexOf(dir) !== -1;\n  } else if (typeof mode === 'function') {\n    return mode({chart}).indexOf(dir) !== -1;\n  }\n  return false;\n}\nfunction directionsEnabled(mode, chart) {\n  if (typeof mode === 'function') {\n    mode = mode({chart});\n  }\n  if (typeof mode === 'string') {\n    return {x: mode.indexOf('x') !== -1, y: mode.indexOf('y') !== -1};\n  }\n  return {x: false, y: false};\n}\nfunction debounce(fn, delay) {\n  let timeout;\n  return function() {\n    clearTimeout(timeout);\n    timeout = setTimeout(fn, delay);\n    return delay;\n  };\n}\nfunction getScaleUnderPoint({x, y}, chart) {\n  const scales = chart.scales;\n  const scaleIds = Object.keys(scales);\n  for (let i = 0; i < scaleIds.length; i++) {\n    const scale = scales[scaleIds[i]];\n    if (y >= scale.top && y <= scale.bottom && x >= scale.left && x <= scale.right) {\n      return scale;\n    }\n  }\n  return null;\n}\nfunction getEnabledScalesByPoint(options, point, chart) {\n  const {mode = 'xy', scaleMode, overScaleMode} = options || {};\n  const scale = getScaleUnderPoint(point, chart);\n  const enabled = directionsEnabled(mode, chart);\n  const scaleEnabled = directionsEnabled(scaleMode, chart);\n  if (overScaleMode) {\n    const overScaleEnabled = directionsEnabled(overScaleMode, chart);\n    for (const axis of ['x', 'y']) {\n      if (overScaleEnabled[axis]) {\n        scaleEnabled[axis] = enabled[axis];\n        enabled[axis] = false;\n      }\n    }\n  }\n  if (scale && scaleEnabled[scale.axis]) {\n    return [scale];\n  }\n  const enabledScales = [];\n  each(chart.scales, function(scaleItem) {\n    if (enabled[scaleItem.axis]) {\n      enabledScales.push(scaleItem);\n    }\n  });\n  return enabledScales;\n}\n\nconst chartStates = new WeakMap();\nfunction getState(chart) {\n  let state = chartStates.get(chart);\n  if (!state) {\n    state = {\n      originalScaleLimits: {},\n      updatedScaleLimits: {},\n      handlers: {},\n      panDelta: {},\n      dragging: false,\n      panning: false\n    };\n    chartStates.set(chart, state);\n  }\n  return state;\n}\nfunction removeState(chart) {\n  chartStates.delete(chart);\n}\n\nfunction zoomDelta(val, min, range, newRange) {\n  const minPercent = Math.max(0, Math.min(1, (val - min) / range || 0));\n  const maxPercent = 1 - minPercent;\n  return {\n    min: newRange * minPercent,\n    max: newRange * maxPercent\n  };\n}\nfunction getValueAtPoint(scale, point) {\n  const pixel = scale.isHorizontal() ? point.x : point.y;\n  return scale.getValueForPixel(pixel);\n}\nfunction linearZoomDelta(scale, zoom, center) {\n  const range = scale.max - scale.min;\n  const newRange = range * (zoom - 1);\n  const centerValue = getValueAtPoint(scale, center);\n  return zoomDelta(centerValue, scale.min, range, newRange);\n}\nfunction logarithmicZoomRange(scale, zoom, center) {\n  const centerValue = getValueAtPoint(scale, center);\n  if (centerValue === undefined) {\n    return {min: scale.min, max: scale.max};\n  }\n  const logMin = Math.log10(scale.min);\n  const logMax = Math.log10(scale.max);\n  const logCenter = Math.log10(centerValue);\n  const logRange = logMax - logMin;\n  const newLogRange = logRange * (zoom - 1);\n  const delta = zoomDelta(logCenter, logMin, logRange, newLogRange);\n  return {\n    min: Math.pow(10, logMin + delta.min),\n    max: Math.pow(10, logMax - delta.max),\n  };\n}\nfunction getScaleLimits(scale, limits) {\n  return limits && (limits[scale.id] || limits[scale.axis]) || {};\n}\nfunction getLimit(state, scale, scaleLimits, prop, fallback) {\n  let limit = scaleLimits[prop];\n  if (limit === 'original') {\n    const original = state.originalScaleLimits[scale.id][prop];\n    limit = valueOrDefault(original.options, original.scale);\n  }\n  return valueOrDefault(limit, fallback);\n}\nfunction linearRange(scale, pixel0, pixel1) {\n  const v0 = scale.getValueForPixel(pixel0);\n  const v1 = scale.getValueForPixel(pixel1);\n  return {\n    min: Math.min(v0, v1),\n    max: Math.max(v0, v1)\n  };\n}\nfunction fixRange(range, {min, max, minLimit, maxLimit}, originalLimits) {\n  const offset = (range - max + min) / 2;\n  min -= offset;\n  max += offset;\n  const origMin = originalLimits.min.options ?? originalLimits.min.scale;\n  const origMax = originalLimits.max.options ?? originalLimits.max.scale;\n  const epsilon = range / 1e6;\n  if (almostEquals(min, origMin, epsilon)) {\n    min = origMin;\n  }\n  if (almostEquals(max, origMax, epsilon)) {\n    max = origMax;\n  }\n  if (min < minLimit) {\n    min = minLimit;\n    max = Math.min(minLimit + range, maxLimit);\n  } else if (max > maxLimit) {\n    max = maxLimit;\n    min = Math.max(maxLimit - range, minLimit);\n  }\n  return {min, max};\n}\nfunction updateRange(scale, {min, max}, limits, zoom = false) {\n  const state = getState(scale.chart);\n  const {options: scaleOpts} = scale;\n  const scaleLimits = getScaleLimits(scale, limits);\n  const {minRange = 0} = scaleLimits;\n  const minLimit = getLimit(state, scale, scaleLimits, 'min', -Infinity);\n  const maxLimit = getLimit(state, scale, scaleLimits, 'max', Infinity);\n  if (zoom === 'pan' && (min < minLimit || max > maxLimit)) {\n    return true;\n  }\n  const scaleRange = scale.max - scale.min;\n  const range = zoom ? Math.max(max - min, minRange) : scaleRange;\n  if (zoom && range === minRange && scaleRange <= minRange) {\n    return true;\n  }\n  const newRange = fixRange(range, {min, max, minLimit, maxLimit}, state.originalScaleLimits[scale.id]);\n  scaleOpts.min = newRange.min;\n  scaleOpts.max = newRange.max;\n  state.updatedScaleLimits[scale.id] = newRange;\n  return scale.parse(newRange.min) !== scale.min || scale.parse(newRange.max) !== scale.max;\n}\nfunction zoomNumericalScale(scale, zoom, center, limits) {\n  const delta = linearZoomDelta(scale, zoom, center);\n  const newRange = {min: scale.min + delta.min, max: scale.max - delta.max};\n  return updateRange(scale, newRange, limits, true);\n}\nfunction zoomLogarithmicScale(scale, zoom, center, limits) {\n  const newRange = logarithmicZoomRange(scale, zoom, center);\n  return updateRange(scale, newRange, limits, true);\n}\nfunction zoomRectNumericalScale(scale, from, to, limits) {\n  updateRange(scale, linearRange(scale, from, to), limits, true);\n}\nconst integerChange = (v) => v === 0 || isNaN(v) ? 0 : v < 0 ? Math.min(Math.round(v), -1) : Math.max(Math.round(v), 1);\nfunction existCategoryFromMaxZoom(scale) {\n  const labels = scale.getLabels();\n  const maxIndex = labels.length - 1;\n  if (scale.min > 0) {\n    scale.min -= 1;\n  }\n  if (scale.max < maxIndex) {\n    scale.max += 1;\n  }\n}\nfunction zoomCategoryScale(scale, zoom, center, limits) {\n  const delta = linearZoomDelta(scale, zoom, center);\n  if (scale.min === scale.max && zoom < 1) {\n    existCategoryFromMaxZoom(scale);\n  }\n  const newRange = {min: scale.min + integerChange(delta.min), max: scale.max - integerChange(delta.max)};\n  return updateRange(scale, newRange, limits, true);\n}\nfunction scaleLength(scale) {\n  return scale.isHorizontal() ? scale.width : scale.height;\n}\nfunction panCategoryScale(scale, delta, limits) {\n  const labels = scale.getLabels();\n  const lastLabelIndex = labels.length - 1;\n  let {min, max} = scale;\n  const range = Math.max(max - min, 1);\n  const stepDelta = Math.round(scaleLength(scale) / Math.max(range, 10));\n  const stepSize = Math.round(Math.abs(delta / stepDelta));\n  let applied;\n  if (delta < -stepDelta) {\n    max = Math.min(max + stepSize, lastLabelIndex);\n    min = range === 1 ? max : max - range;\n    applied = max === lastLabelIndex;\n  } else if (delta > stepDelta) {\n    min = Math.max(0, min - stepSize);\n    max = range === 1 ? min : min + range;\n    applied = min === 0;\n  }\n  return updateRange(scale, {min, max}, limits) || applied;\n}\nconst OFFSETS = {\n  second: 500,\n  minute: 30 * 1000,\n  hour: 30 * 60 * 1000,\n  day: 12 * 60 * 60 * 1000,\n  week: 3.5 * 24 * 60 * 60 * 1000,\n  month: 15 * 24 * 60 * 60 * 1000,\n  quarter: 60 * 24 * 60 * 60 * 1000,\n  year: 182 * 24 * 60 * 60 * 1000\n};\nfunction panNumericalScale(scale, delta, limits, pan = false) {\n  const {min: prevStart, max: prevEnd, options} = scale;\n  const round = options.time && options.time.round;\n  const offset = OFFSETS[round] || 0;\n  const newMin = scale.getValueForPixel(scale.getPixelForValue(prevStart + offset) - delta);\n  const newMax = scale.getValueForPixel(scale.getPixelForValue(prevEnd + offset) - delta);\n  if (isNaN(newMin) || isNaN(newMax)) {\n    return true;\n  }\n  return updateRange(scale, {min: newMin, max: newMax}, limits, pan ? 'pan' : false);\n}\nfunction panNonLinearScale(scale, delta, limits) {\n  return panNumericalScale(scale, delta, limits, true);\n}\nconst zoomFunctions = {\n  category: zoomCategoryScale,\n  default: zoomNumericalScale,\n  logarithmic: zoomLogarithmicScale,\n};\nconst zoomRectFunctions = {\n  default: zoomRectNumericalScale,\n};\nconst panFunctions = {\n  category: panCategoryScale,\n  default: panNumericalScale,\n  logarithmic: panNonLinearScale,\n  timeseries: panNonLinearScale,\n};\n\nfunction shouldUpdateScaleLimits(scale, originalScaleLimits, updatedScaleLimits) {\n  const {id, options: {min, max}} = scale;\n  if (!originalScaleLimits[id] || !updatedScaleLimits[id]) {\n    return true;\n  }\n  const previous = updatedScaleLimits[id];\n  return previous.min !== min || previous.max !== max;\n}\nfunction removeMissingScales(limits, scales) {\n  each(limits, (opt, key) => {\n    if (!scales[key]) {\n      delete limits[key];\n    }\n  });\n}\nfunction storeOriginalScaleLimits(chart, state) {\n  const {scales} = chart;\n  const {originalScaleLimits, updatedScaleLimits} = state;\n  each(scales, function(scale) {\n    if (shouldUpdateScaleLimits(scale, originalScaleLimits, updatedScaleLimits)) {\n      originalScaleLimits[scale.id] = {\n        min: {scale: scale.min, options: scale.options.min},\n        max: {scale: scale.max, options: scale.options.max},\n      };\n    }\n  });\n  removeMissingScales(originalScaleLimits, scales);\n  removeMissingScales(updatedScaleLimits, scales);\n  return originalScaleLimits;\n}\nfunction doZoom(scale, amount, center, limits) {\n  const fn = zoomFunctions[scale.type] || zoomFunctions.default;\n  callback(fn, [scale, amount, center, limits]);\n}\nfunction doZoomRect(scale, from, to, limits) {\n  const fn = zoomRectFunctions[scale.type] || zoomRectFunctions.default;\n  callback(fn, [scale, from, to, limits]);\n}\nfunction getCenter(chart) {\n  const ca = chart.chartArea;\n  return {\n    x: (ca.left + ca.right) / 2,\n    y: (ca.top + ca.bottom) / 2,\n  };\n}\nfunction zoom(chart, amount, transition = 'none', trigger = 'api') {\n  const {x = 1, y = 1, focalPoint = getCenter(chart)} = typeof amount === 'number' ? {x: amount, y: amount} : amount;\n  const state = getState(chart);\n  const {options: {limits, zoom: zoomOptions}} = state;\n  storeOriginalScaleLimits(chart, state);\n  const xEnabled = x !== 1;\n  const yEnabled = y !== 1;\n  const enabledScales = getEnabledScalesByPoint(zoomOptions, focalPoint, chart);\n  each(enabledScales || chart.scales, function(scale) {\n    if (scale.isHorizontal() && xEnabled) {\n      doZoom(scale, x, focalPoint, limits);\n    } else if (!scale.isHorizontal() && yEnabled) {\n      doZoom(scale, y, focalPoint, limits);\n    }\n  });\n  chart.update(transition);\n  callback(zoomOptions.onZoom, [{chart, trigger}]);\n}\nfunction zoomRect(chart, p0, p1, transition = 'none', trigger = 'api') {\n  const state = getState(chart);\n  const {options: {limits, zoom: zoomOptions}} = state;\n  const {mode = 'xy'} = zoomOptions;\n  storeOriginalScaleLimits(chart, state);\n  const xEnabled = directionEnabled(mode, 'x', chart);\n  const yEnabled = directionEnabled(mode, 'y', chart);\n  each(chart.scales, function(scale) {\n    if (scale.isHorizontal() && xEnabled) {\n      doZoomRect(scale, p0.x, p1.x, limits);\n    } else if (!scale.isHorizontal() && yEnabled) {\n      doZoomRect(scale, p0.y, p1.y, limits);\n    }\n  });\n  chart.update(transition);\n  callback(zoomOptions.onZoom, [{chart, trigger}]);\n}\nfunction zoomScale(chart, scaleId, range, transition = 'none', trigger = 'api') {\n  const state = getState(chart);\n  storeOriginalScaleLimits(chart, state);\n  const scale = chart.scales[scaleId];\n  updateRange(scale, range, undefined, true);\n  chart.update(transition);\n  callback(state.options.zoom?.onZoom, [{chart, trigger}]);\n}\nfunction resetZoom(chart, transition = 'default') {\n  const state = getState(chart);\n  const originalScaleLimits = storeOriginalScaleLimits(chart, state);\n  each(chart.scales, function(scale) {\n    const scaleOptions = scale.options;\n    if (originalScaleLimits[scale.id]) {\n      scaleOptions.min = originalScaleLimits[scale.id].min.options;\n      scaleOptions.max = originalScaleLimits[scale.id].max.options;\n    } else {\n      delete scaleOptions.min;\n      delete scaleOptions.max;\n    }\n    delete state.updatedScaleLimits[scale.id];\n  });\n  chart.update(transition);\n  callback(state.options.zoom.onZoomComplete, [{chart}]);\n}\nfunction getOriginalRange(state, scaleId) {\n  const original = state.originalScaleLimits[scaleId];\n  if (!original) {\n    return;\n  }\n  const {min, max} = original;\n  return valueOrDefault(max.options, max.scale) - valueOrDefault(min.options, min.scale);\n}\nfunction getZoomLevel(chart) {\n  const state = getState(chart);\n  let min = 1;\n  let max = 1;\n  each(chart.scales, function(scale) {\n    const origRange = getOriginalRange(state, scale.id);\n    if (origRange) {\n      const level = Math.round(origRange / (scale.max - scale.min) * 100) / 100;\n      min = Math.min(min, level);\n      max = Math.max(max, level);\n    }\n  });\n  return min < 1 ? min : max;\n}\nfunction panScale(scale, delta, limits, state) {\n  const {panDelta} = state;\n  const storedDelta = panDelta[scale.id] || 0;\n  if (sign(storedDelta) === sign(delta)) {\n    delta += storedDelta;\n  }\n  const fn = panFunctions[scale.type] || panFunctions.default;\n  if (callback(fn, [scale, delta, limits])) {\n    panDelta[scale.id] = 0;\n  } else {\n    panDelta[scale.id] = delta;\n  }\n}\nfunction pan(chart, delta, enabledScales, transition = 'none') {\n  const {x = 0, y = 0} = typeof delta === 'number' ? {x: delta, y: delta} : delta;\n  const state = getState(chart);\n  const {options: {pan: panOptions, limits}} = state;\n  const {onPan} = panOptions || {};\n  storeOriginalScaleLimits(chart, state);\n  const xEnabled = x !== 0;\n  const yEnabled = y !== 0;\n  each(enabledScales || chart.scales, function(scale) {\n    if (scale.isHorizontal() && xEnabled) {\n      panScale(scale, x, limits, state);\n    } else if (!scale.isHorizontal() && yEnabled) {\n      panScale(scale, y, limits, state);\n    }\n  });\n  chart.update(transition);\n  callback(onPan, [{chart}]);\n}\nfunction getInitialScaleBounds(chart) {\n  const state = getState(chart);\n  storeOriginalScaleLimits(chart, state);\n  const scaleBounds = {};\n  for (const scaleId of Object.keys(chart.scales)) {\n    const {min, max} = state.originalScaleLimits[scaleId] || {min: {}, max: {}};\n    scaleBounds[scaleId] = {min: min.scale, max: max.scale};\n  }\n  return scaleBounds;\n}\nfunction getZoomedScaleBounds(chart) {\n  const state = getState(chart);\n  const scaleBounds = {};\n  for (const scaleId of Object.keys(chart.scales)) {\n    scaleBounds[scaleId] = state.updatedScaleLimits[scaleId];\n  }\n  return scaleBounds;\n}\nfunction isZoomedOrPanned(chart) {\n  const scaleBounds = getInitialScaleBounds(chart);\n  for (const scaleId of Object.keys(chart.scales)) {\n    const {min: originalMin, max: originalMax} = scaleBounds[scaleId];\n    if (originalMin !== undefined && chart.scales[scaleId].min !== originalMin) {\n      return true;\n    }\n    if (originalMax !== undefined && chart.scales[scaleId].max !== originalMax) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction isZoomingOrPanning(chart) {\n  const state = getState(chart);\n  return state.panning || state.dragging;\n}\n\nconst clamp = (x, from, to) => Math.min(to, Math.max(from, x));\nfunction removeHandler(chart, type) {\n  const {handlers} = getState(chart);\n  const handler = handlers[type];\n  if (handler && handler.target) {\n    handler.target.removeEventListener(type, handler);\n    delete handlers[type];\n  }\n}\nfunction addHandler(chart, target, type, handler) {\n  const {handlers, options} = getState(chart);\n  const oldHandler = handlers[type];\n  if (oldHandler && oldHandler.target === target) {\n    return;\n  }\n  removeHandler(chart, type);\n  handlers[type] = (event) => handler(chart, event, options);\n  handlers[type].target = target;\n  const passive = type === 'wheel' ? false : undefined;\n  target.addEventListener(type, handlers[type], {passive});\n}\nfunction mouseMove(chart, event) {\n  const state = getState(chart);\n  if (state.dragStart) {\n    state.dragging = true;\n    state.dragEnd = event;\n    chart.update('none');\n  }\n}\nfunction keyDown(chart, event) {\n  const state = getState(chart);\n  if (!state.dragStart || event.key !== 'Escape') {\n    return;\n  }\n  removeHandler(chart, 'keydown');\n  state.dragging = false;\n  state.dragStart = state.dragEnd = null;\n  chart.update('none');\n}\nfunction getPointPosition(event, chart) {\n  if (event.target !== chart.canvas) {\n    const canvasArea = chart.canvas.getBoundingClientRect();\n    return {\n      x: event.clientX - canvasArea.left,\n      y: event.clientY - canvasArea.top,\n    };\n  }\n  return getRelativePosition(event, chart);\n}\nfunction zoomStart(chart, event, zoomOptions) {\n  const {onZoomStart, onZoomRejected} = zoomOptions;\n  if (onZoomStart) {\n    const point = getPointPosition(event, chart);\n    if (callback(onZoomStart, [{chart, event, point}]) === false) {\n      callback(onZoomRejected, [{chart, event}]);\n      return false;\n    }\n  }\n}\nfunction mouseDown(chart, event) {\n  if (chart.legend) {\n    const point = getRelativePosition(event, chart);\n    if (_isPointInArea(point, chart.legend)) {\n      return;\n    }\n  }\n  const state = getState(chart);\n  const {pan: panOptions, zoom: zoomOptions = {}} = state.options;\n  if (\n    event.button !== 0 ||\n    keyPressed(getModifierKey(panOptions), event) ||\n    keyNotPressed(getModifierKey(zoomOptions.drag), event)\n  ) {\n    return callback(zoomOptions.onZoomRejected, [{chart, event}]);\n  }\n  if (zoomStart(chart, event, zoomOptions) === false) {\n    return;\n  }\n  state.dragStart = event;\n  addHandler(chart, chart.canvas.ownerDocument, 'mousemove', mouseMove);\n  addHandler(chart, window.document, 'keydown', keyDown);\n}\nfunction applyAspectRatio({begin, end}, aspectRatio) {\n  let width = end.x - begin.x;\n  let height = end.y - begin.y;\n  const ratio = Math.abs(width / height);\n  if (ratio > aspectRatio) {\n    width = Math.sign(width) * Math.abs(height * aspectRatio);\n  } else if (ratio < aspectRatio) {\n    height = Math.sign(height) * Math.abs(width / aspectRatio);\n  }\n  end.x = begin.x + width;\n  end.y = begin.y + height;\n}\nfunction applyMinMaxProps(rect, chartArea, points, {min, max, prop}) {\n  rect[min] = clamp(Math.min(points.begin[prop], points.end[prop]), chartArea[min], chartArea[max]);\n  rect[max] = clamp(Math.max(points.begin[prop], points.end[prop]), chartArea[min], chartArea[max]);\n}\nfunction getRelativePoints(chart, pointEvents, maintainAspectRatio) {\n  const points = {\n    begin: getPointPosition(pointEvents.dragStart, chart),\n    end: getPointPosition(pointEvents.dragEnd, chart),\n  };\n  if (maintainAspectRatio) {\n    const aspectRatio = chart.chartArea.width / chart.chartArea.height;\n    applyAspectRatio(points, aspectRatio);\n  }\n  return points;\n}\nfunction computeDragRect(chart, mode, pointEvents, maintainAspectRatio) {\n  const xEnabled = directionEnabled(mode, 'x', chart);\n  const yEnabled = directionEnabled(mode, 'y', chart);\n  const {top, left, right, bottom, width: chartWidth, height: chartHeight} = chart.chartArea;\n  const rect = {top, left, right, bottom};\n  const points = getRelativePoints(chart, pointEvents, maintainAspectRatio && xEnabled && yEnabled);\n  if (xEnabled) {\n    applyMinMaxProps(rect, chart.chartArea, points, {min: 'left', max: 'right', prop: 'x'});\n  }\n  if (yEnabled) {\n    applyMinMaxProps(rect, chart.chartArea, points, {min: 'top', max: 'bottom', prop: 'y'});\n  }\n  const width = rect.right - rect.left;\n  const height = rect.bottom - rect.top;\n  return {\n    ...rect,\n    width,\n    height,\n    zoomX: xEnabled && width ? 1 + ((chartWidth - width) / chartWidth) : 1,\n    zoomY: yEnabled && height ? 1 + ((chartHeight - height) / chartHeight) : 1\n  };\n}\nfunction mouseUp(chart, event) {\n  const state = getState(chart);\n  if (!state.dragStart) {\n    return;\n  }\n  removeHandler(chart, 'mousemove');\n  const {mode, onZoomComplete, drag: {threshold = 0, maintainAspectRatio}} = state.options.zoom;\n  const rect = computeDragRect(chart, mode, {dragStart: state.dragStart, dragEnd: event}, maintainAspectRatio);\n  const distanceX = directionEnabled(mode, 'x', chart) ? rect.width : 0;\n  const distanceY = directionEnabled(mode, 'y', chart) ? rect.height : 0;\n  const distance = Math.sqrt(distanceX * distanceX + distanceY * distanceY);\n  state.dragStart = state.dragEnd = null;\n  if (distance <= threshold) {\n    state.dragging = false;\n    chart.update('none');\n    return;\n  }\n  zoomRect(chart, {x: rect.left, y: rect.top}, {x: rect.right, y: rect.bottom}, 'zoom', 'drag');\n  state.dragging = false;\n  state.filterNextClick = true;\n  callback(onZoomComplete, [{chart}]);\n}\nfunction wheelPreconditions(chart, event, zoomOptions) {\n  if (keyNotPressed(getModifierKey(zoomOptions.wheel), event)) {\n    callback(zoomOptions.onZoomRejected, [{chart, event}]);\n    return;\n  }\n  if (zoomStart(chart, event, zoomOptions) === false) {\n    return;\n  }\n  if (event.cancelable) {\n    event.preventDefault();\n  }\n  if (event.deltaY === undefined) {\n    return;\n  }\n  return true;\n}\nfunction wheel(chart, event) {\n  const {handlers: {onZoomComplete}, options: {zoom: zoomOptions}} = getState(chart);\n  if (!wheelPreconditions(chart, event, zoomOptions)) {\n    return;\n  }\n  const rect = event.target.getBoundingClientRect();\n  const speed = zoomOptions.wheel.speed;\n  const percentage = event.deltaY >= 0 ? 2 - 1 / (1 - speed) : 1 + speed;\n  const amount = {\n    x: percentage,\n    y: percentage,\n    focalPoint: {\n      x: event.clientX - rect.left,\n      y: event.clientY - rect.top\n    }\n  };\n  zoom(chart, amount, 'zoom', 'wheel');\n  callback(onZoomComplete, [{chart}]);\n}\nfunction addDebouncedHandler(chart, name, handler, delay) {\n  if (handler) {\n    getState(chart).handlers[name] = debounce(() => callback(handler, [{chart}]), delay);\n  }\n}\nfunction addListeners(chart, options) {\n  const canvas = chart.canvas;\n  const {wheel: wheelOptions, drag: dragOptions, onZoomComplete} = options.zoom;\n  if (wheelOptions.enabled) {\n    addHandler(chart, canvas, 'wheel', wheel);\n    addDebouncedHandler(chart, 'onZoomComplete', onZoomComplete, 250);\n  } else {\n    removeHandler(chart, 'wheel');\n  }\n  if (dragOptions.enabled) {\n    addHandler(chart, canvas, 'mousedown', mouseDown);\n    addHandler(chart, canvas.ownerDocument, 'mouseup', mouseUp);\n  } else {\n    removeHandler(chart, 'mousedown');\n    removeHandler(chart, 'mousemove');\n    removeHandler(chart, 'mouseup');\n    removeHandler(chart, 'keydown');\n  }\n}\nfunction removeListeners(chart) {\n  removeHandler(chart, 'mousedown');\n  removeHandler(chart, 'mousemove');\n  removeHandler(chart, 'mouseup');\n  removeHandler(chart, 'wheel');\n  removeHandler(chart, 'click');\n  removeHandler(chart, 'keydown');\n}\n\nfunction createEnabler(chart, state) {\n  return function(recognizer, event) {\n    const {pan: panOptions, zoom: zoomOptions = {}} = state.options;\n    if (!panOptions || !panOptions.enabled) {\n      return false;\n    }\n    const srcEvent = event && event.srcEvent;\n    if (!srcEvent) {\n      return true;\n    }\n    if (!state.panning && event.pointerType === 'mouse' && (\n      keyNotPressed(getModifierKey(panOptions), srcEvent) || keyPressed(getModifierKey(zoomOptions.drag), srcEvent))\n    ) {\n      callback(panOptions.onPanRejected, [{chart, event}]);\n      return false;\n    }\n    return true;\n  };\n}\nfunction pinchAxes(p0, p1) {\n  const pinchX = Math.abs(p0.clientX - p1.clientX);\n  const pinchY = Math.abs(p0.clientY - p1.clientY);\n  const p = pinchX / pinchY;\n  let x, y;\n  if (p > 0.3 && p < 1.7) {\n    x = y = true;\n  } else if (pinchX > pinchY) {\n    x = true;\n  } else {\n    y = true;\n  }\n  return {x, y};\n}\nfunction handlePinch(chart, state, e) {\n  if (state.scale) {\n    const {center, pointers} = e;\n    const zoomPercent = 1 / state.scale * e.scale;\n    const rect = e.target.getBoundingClientRect();\n    const pinch = pinchAxes(pointers[0], pointers[1]);\n    const mode = state.options.zoom.mode;\n    const amount = {\n      x: pinch.x && directionEnabled(mode, 'x', chart) ? zoomPercent : 1,\n      y: pinch.y && directionEnabled(mode, 'y', chart) ? zoomPercent : 1,\n      focalPoint: {\n        x: center.x - rect.left,\n        y: center.y - rect.top\n      }\n    };\n    zoom(chart, amount, 'zoom', 'pinch');\n    state.scale = e.scale;\n  }\n}\nfunction startPinch(chart, state, event) {\n  if (state.options.zoom.pinch.enabled) {\n    const point = getRelativePosition(event, chart);\n    if (callback(state.options.zoom.onZoomStart, [{chart, event, point}]) === false) {\n      state.scale = null;\n      callback(state.options.zoom.onZoomRejected, [{chart, event}]);\n    } else {\n      state.scale = 1;\n    }\n  }\n}\nfunction endPinch(chart, state, e) {\n  if (state.scale) {\n    handlePinch(chart, state, e);\n    state.scale = null;\n    callback(state.options.zoom.onZoomComplete, [{chart}]);\n  }\n}\nfunction handlePan(chart, state, e) {\n  const delta = state.delta;\n  if (delta) {\n    state.panning = true;\n    pan(chart, {x: e.deltaX - delta.x, y: e.deltaY - delta.y}, state.panScales);\n    state.delta = {x: e.deltaX, y: e.deltaY};\n  }\n}\nfunction startPan(chart, state, event) {\n  const {enabled, onPanStart, onPanRejected} = state.options.pan;\n  if (!enabled) {\n    return;\n  }\n  const rect = event.target.getBoundingClientRect();\n  const point = {\n    x: event.center.x - rect.left,\n    y: event.center.y - rect.top\n  };\n  if (callback(onPanStart, [{chart, event, point}]) === false) {\n    return callback(onPanRejected, [{chart, event}]);\n  }\n  state.panScales = getEnabledScalesByPoint(state.options.pan, point, chart);\n  state.delta = {x: 0, y: 0};\n  handlePan(chart, state, event);\n}\nfunction endPan(chart, state) {\n  state.delta = null;\n  if (state.panning) {\n    state.panning = false;\n    state.filterNextClick = true;\n    callback(state.options.pan.onPanComplete, [{chart}]);\n  }\n}\nconst hammers = new WeakMap();\nfunction startHammer(chart, options) {\n  const state = getState(chart);\n  const canvas = chart.canvas;\n  const {pan: panOptions, zoom: zoomOptions} = options;\n  const mc = new Hammer.Manager(canvas);\n  if (zoomOptions && zoomOptions.pinch.enabled) {\n    mc.add(new Hammer.Pinch());\n    mc.on('pinchstart', (e) => startPinch(chart, state, e));\n    mc.on('pinch', (e) => handlePinch(chart, state, e));\n    mc.on('pinchend', (e) => endPinch(chart, state, e));\n  }\n  if (panOptions && panOptions.enabled) {\n    mc.add(new Hammer.Pan({\n      threshold: panOptions.threshold,\n      enable: createEnabler(chart, state)\n    }));\n    mc.on('panstart', (e) => startPan(chart, state, e));\n    mc.on('panmove', (e) => handlePan(chart, state, e));\n    mc.on('panend', () => endPan(chart, state));\n  }\n  hammers.set(chart, mc);\n}\nfunction stopHammer(chart) {\n  const mc = hammers.get(chart);\n  if (mc) {\n    mc.remove('pinchstart');\n    mc.remove('pinch');\n    mc.remove('pinchend');\n    mc.remove('panstart');\n    mc.remove('pan');\n    mc.remove('panend');\n    mc.destroy();\n    hammers.delete(chart);\n  }\n}\nfunction hammerOptionsChanged(oldOptions, newOptions) {\n  const {pan: oldPan, zoom: oldZoom} = oldOptions;\n  const {pan: newPan, zoom: newZoom} = newOptions;\n  if (oldZoom?.zoom?.pinch?.enabled !== newZoom?.zoom?.pinch?.enabled) {\n    return true;\n  }\n  if (oldPan?.enabled !== newPan?.enabled) {\n    return true;\n  }\n  if (oldPan?.threshold !== newPan?.threshold) {\n    return true;\n  }\n  return false;\n}\n\nvar version = \"2.2.0\";\n\nfunction draw(chart, caller, options) {\n  const dragOptions = options.zoom.drag;\n  const {dragStart, dragEnd} = getState(chart);\n  if (dragOptions.drawTime !== caller || !dragEnd) {\n    return;\n  }\n  const {left, top, width, height} = computeDragRect(chart, options.zoom.mode, {dragStart, dragEnd}, dragOptions.maintainAspectRatio);\n  const ctx = chart.ctx;\n  ctx.save();\n  ctx.beginPath();\n  ctx.fillStyle = dragOptions.backgroundColor || 'rgba(225,225,225,0.3)';\n  ctx.fillRect(left, top, width, height);\n  if (dragOptions.borderWidth > 0) {\n    ctx.lineWidth = dragOptions.borderWidth;\n    ctx.strokeStyle = dragOptions.borderColor || 'rgba(225,225,225)';\n    ctx.strokeRect(left, top, width, height);\n  }\n  ctx.restore();\n}\nvar plugin = {\n  id: 'zoom',\n  version,\n  defaults: {\n    pan: {\n      enabled: false,\n      mode: 'xy',\n      threshold: 10,\n      modifierKey: null,\n    },\n    zoom: {\n      wheel: {\n        enabled: false,\n        speed: 0.1,\n        modifierKey: null\n      },\n      drag: {\n        enabled: false,\n        drawTime: 'beforeDatasetsDraw',\n        modifierKey: null\n      },\n      pinch: {\n        enabled: false\n      },\n      mode: 'xy',\n    }\n  },\n  start: function(chart, _args, options) {\n    const state = getState(chart);\n    state.options = options;\n    if (Object.prototype.hasOwnProperty.call(options.zoom, 'enabled')) {\n      console.warn('The option `zoom.enabled` is no longer supported. Please use `zoom.wheel.enabled`, `zoom.drag.enabled`, or `zoom.pinch.enabled`.');\n    }\n    if (Object.prototype.hasOwnProperty.call(options.zoom, 'overScaleMode')\n      || Object.prototype.hasOwnProperty.call(options.pan, 'overScaleMode')) {\n      console.warn('The option `overScaleMode` is deprecated. Please use `scaleMode` instead (and update `mode` as desired).');\n    }\n    if (Hammer) {\n      startHammer(chart, options);\n    }\n    chart.pan = (delta, panScales, transition) => pan(chart, delta, panScales, transition);\n    chart.zoom = (args, transition) => zoom(chart, args, transition);\n    chart.zoomRect = (p0, p1, transition) => zoomRect(chart, p0, p1, transition);\n    chart.zoomScale = (id, range, transition) => zoomScale(chart, id, range, transition);\n    chart.resetZoom = (transition) => resetZoom(chart, transition);\n    chart.getZoomLevel = () => getZoomLevel(chart);\n    chart.getInitialScaleBounds = () => getInitialScaleBounds(chart);\n    chart.getZoomedScaleBounds = () => getZoomedScaleBounds(chart);\n    chart.isZoomedOrPanned = () => isZoomedOrPanned(chart);\n    chart.isZoomingOrPanning = () => isZoomingOrPanning(chart);\n  },\n  beforeEvent(chart, {event}) {\n    if (isZoomingOrPanning(chart)) {\n      return false;\n    }\n    if (event.type === 'click' || event.type === 'mouseup') {\n      const state = getState(chart);\n      if (state.filterNextClick) {\n        state.filterNextClick = false;\n        return false;\n      }\n    }\n  },\n  beforeUpdate: function(chart, args, options) {\n    const state = getState(chart);\n    const previousOptions = state.options;\n    state.options = options;\n    if (hammerOptionsChanged(previousOptions, options)) {\n      stopHammer(chart);\n      startHammer(chart, options);\n    }\n    addListeners(chart, options);\n  },\n  beforeDatasetsDraw(chart, _args, options) {\n    draw(chart, 'beforeDatasetsDraw', options);\n  },\n  afterDatasetsDraw(chart, _args, options) {\n    draw(chart, 'afterDatasetsDraw', options);\n  },\n  beforeDraw(chart, _args, options) {\n    draw(chart, 'beforeDraw', options);\n  },\n  afterDraw(chart, _args, options) {\n    draw(chart, 'afterDraw', options);\n  },\n  stop: function(chart) {\n    removeListeners(chart);\n    if (Hammer) {\n      stopHammer(chart);\n    }\n    removeState(chart);\n  },\n  panFunctions,\n  zoomFunctions,\n  zoomRectFunctions,\n};\n\nexport { plugin as default, pan, resetZoom, zoom, zoomRect, zoomScale };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}